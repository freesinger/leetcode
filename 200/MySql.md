1. 数据库三大范式说一下？

```text
/* 建表规范 */ ------------------
    -- Normal Format, NF
        - 每个表保存一个实体信息
        - 每个具有一个ID字段作为主键
        - ID主键 + 原子表
    -- 1NF, 第一范式
        字段不能再分，就满足第一范式。
    -- 2NF, 第二范式
        满足第一范式的前提下，不能出现部分依赖（某一列不依赖于主键）。
        消除复合主键就可以避免部分依赖。增加单列关键字。
    -- 3NF, 第三范式
        满足第二范式的前提下，不能出现传递依赖。
        某个字段依赖于主键，而有其他字段依赖于该字段。这就是传递依赖。
        将一个实体信息的数据放在一个表内实现。
```

2. mysql的存储引擎以及他们的区别？

最常用的是InnoDB和MyISAM，其他的还有Archive, CSV等等。InnoDB是MySql的默认存储引擎。

简单说下前两者区别：
- 是否支持事务和奔溃恢复。InnoDB提供事务支持，外键等高级数据库功能，提供了具有提交、回滚、崩溃恢复能力的事务安全；
MyISAM强调性能，查询具有原子性，速度一般比I更快，但不提供事务支持。
- 是否支持行级锁：M是表级锁，I支持行级锁（默认）和表级锁
- 是否支持MVCC：I支持。应对⾼并发事务, MVCC⽐单纯的加锁更⾼效;MVCC只在 READ COMMITTED 和 REPEATABLE READ 两个隔离级别下⼯作;MVCC可以使⽤ 乐观 (optimistic)锁 和 悲观(pessimistic)锁来实现;
- 外键支持：I支持，M不支持
- 全文索引支持：I不支持，M支持

3. 索引的类型？mysql 索引是怎么实现的？两种存储引擎对实现索引的区别？

InnoDB支持的索引：主键索引(PRIMARY)，普通索引(INDEX)，唯一索引(UNIQUE)，组合索引，全文索引(FULLTEXT)。总体划分为两类，主键索引也被称为聚簇索引（clustered index），其余都称呼为非主键索引也被称为二级索引（secondary index）。

Btree索引和Hash索引。需求为单条记录查询可以使用hash且不能使用除=之外的判断。hash不支持顺序和范围查询是最大的缺点。

两种引擎都是使用B+tree。[图文](https://www.jianshu.com/p/3a1377883742)

- InnoDB：数据文件本身就是主索引文件，按照B+tree结构组织文件，因此每个叶子结点存储就是完整的数据记录，
索引的key就是主键，被称为聚集索引，搜索主键非常高效。辅助索引叶子结点存储的是主键值，因此需要再查一次。
- MyISAM：叶子结点data域存放的是数据记录的地址，查询的时候需要取出地址再按地址查询记录。称为非聚集索引。

4. BTree和B+Tree的区别？

- B+只有叶子结点带指向记录的指针，B内部节点也带，在内部节点出现的索引不会再在B的叶子结点出现
- B+所有叶子结点都通过指针连接在一起

B+优点：
- 非叶子结点不存指针，可以容纳更多索引项，使得内部结点可以定位更多的叶子结点，降低树的高度，从而提升索引查询效率
- 范围扫描很方便，直接在叶子结点进行扫描即可，B树则需要在叶子和内部节点之间来回移动

B优点：对于内部节点可以直接获得，不需要到叶子结点才能获取

5. 索引覆盖了解吗？解释一下为什么要用？

覆盖索引（covering index ，或称为索引覆盖）即从非主键索引中就能查到的记录，而不需要查询主键索引中的记录，避免了回表的产生减少了树的搜索次数，显著提升性能。

6. 事务？特性？讲一下ACID?

事务是逻辑上的一组操作，要么都执行，要么都不执行。
- 原子性（Atomicity）： 事务是最小的执行单位，不允许分割。事务的原子性确保动作要么全部完成，要么完全不起作用；
- 一致性（Consistency）： 执行事务前后，数据保持一致，多个事务对同一个数据读取的结果是相同的；
`应用系统从一个正确的状态到另一个正确的状态.而ACID就是说事务能够通过AID来保证这个C的过程.C是目的,AID都是手段。`
- 隔离性（Isolation）： 并发访问数据库时，一个用户的事务不被其他事务所干扰，各并发事务之间数据库是独立的；
- 持久性（Durability）： 一个事务被提交之后。它对数据库中数据的改变是持久的，即使数据库发生故障也不应该对其有任何影响。

7. 并发事务带来哪些问题?

- 脏读：t1访问db数据进行了修改但还未提交，t2访问使用了这些数据；
- 丢失修改：类似cas里的aba问题，多个事务对同一个数据修改，会导致修改被覆盖丢失；
- 不可重复读：t1多次读取同一数据，但t2访问该数据并做了修改，导致t1多次读的时候发现同一数据不一样了。
- 幻读：t1读取同一数据，t2添加了一些数据，t1多次读发现多了一些原来不存在的数据。

8. 事务隔离机制讲一下？

- read uncommitted: 允许读取未提交的数据更改；
- **read committed**（默认隔离级别）: 允许读取事务已提交的数据；
- repeatable read: 对同一字段的数据多次读取都是一样的，除非数据被本事务修改；
- serializable: 完全服从ACID, 事务依次串行。

9. ~~索引优化有哪些方法？~~



10. 大表优化有哪些策略？

- 限定查询范围，先查时间段内数据再查相关信息等
- 读写分离，主数据库写，从负责读
- 垂直分区：提高I/O效率，但会出现主键冗余带来管理的麻烦
- 水平分区：数据切割，多个数据库来存储，适用于数据量很大的情况，但带来了id主键处理、部署等难题

11. 问题排查手段一般有哪些？

- `show processlist`查看当前所有连接信息；
- `explain`查询sql语句的执行计划（有没有使用index之类的）；
- 开启慢查询日志，定位执行最耗时的语句进行优化

12. 性能优化的常用手段？

- 选择正确的存储引擎。尽量使用InnoDB；
- 优化字段的数据类型。如使用tinyint代替int，建索引的时候也可以进一步优化varchar最大长度之类；
- 为常搜索的字段建立索引，覆盖索引等；
- 避免使用select *；
- 使用enum代替varchar，结构紧凑检索快；
- 字段就可能not null，null需要额外的存储空间；
- 采用固定长度的表
- 。。。。。











