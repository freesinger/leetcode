1. JVM中有哪几块内存空间？

- 堆：所有线程共享的一块内存，所有对象实例在堆上创建并分配内存，jvm启动时创建，GC的主要场所
- 方法区（元空间）：存储jvm加载的类信息、常量、静态变量等信息
- 程序计数器：线程私有，相当于一个字节码执行的行号指示器，用来记录线程执行到哪（上下文切换）
- 虚拟机栈：线程私有，由一个个栈帧组成，主要存储局部变量
- 本地方法栈：线程私有，虚拟机调用native方法的栈，用来和操作系统交互

2. 对象创建的过程？

- 类加载：检查该类是否已经被加载、解析和初始化过，没有则执行加载过程；
- 分配内存：分配内存（指针碰撞（内存规整）、空闲列表（内存不规整）），在堆中划出对象所需要的空间
- 初始化零值
- 设置对象头：对象头存储对象的类信息、hashcode、gc分代年龄、是否使用偏向锁等信息
- 执行init方法初始化

3. 类加载过程？classLoader有哪些？双亲委派模型介绍下？

加载-验证-准备-解析-初始化
- 加载：获取二进制字节流，将静态存储结构转换为方法区的运行时数据结构，在堆内存中生成class字节码对象
- 解析
    - 验证：确保符合jvm要求
    - 准备：为变量分配内存并初始化默认值
    - 解析: 符号引用替换为直接引用
- 初始化：类构造器初始化

classLoader：
- BootstrapLoader：启动类加载器，加载lib
- ExtensionLoader：扩展类加载器，加载ext
- AppLoader: 应用程序加载器，加载classpath下的所有jar包和类，面向用户

双亲委派：

在类加载的时候，系统会首先判断当前类是否被加载过。
已经被加载的类会直接返回，否则才会尝试加载。
加载的时候，首先会把该请求委派该父类加载器的 loadClass() 处理，因此所有的请求最终都应该传送到顶层的启动类加载器 BootstrapClassLoader 中。当父类加载器无法处理时，才由自己来处理。当父类加载器为null时，会使用启动类加载器 BootstrapClassLoader 作为父类加载器。

`好处`：
- 看源码：加了锁，可以避免类的重复加载（JVM 区分不同类的方式不仅仅根据类名，相同的类文件被不同的类加载器加载产生的是两个不同的类）；
- 保证核心API不被篡改（如果没有使用双亲委派模型，而是每个类加载器加载自己的话就会出现一些问题，比如我们编写一个称为 java.lang.Object 类的话，那么程序运行的时候，系统就会出现多个不同的 Object 类）

4. 堆内存中对象的分配策略？

- 对象优先在Eden区分配
- 大对象直接进入老年区
- 长期存活对象（old>15）进入老年区

5. java中有哪些引用类型？

- 强引用：gc时不会被回收
- 软引用：内存溢出时gc会被回收
- 弱引用：gc就会被回收
- 虚引用：要求和引用队列一起使用，在gc时返回一个通知

6. 怎么判断对象是否可以被回收？

需要满足三个条件：
- 该类所有实例都被回收
- classLoader被回收
- 类对象没有任何引用，反射也无法访问

7. GC算法？

- 标记-清除：比较出所有需要回收的对象，标记完成统一回收。效率低，且会产生大量碎片空间。
- 复制算法：内存对半分，将存活对象复制到新的内存并将旧的内存全部释放
- 标记-整理：标记之后存活对象向一端移动，再释放边界外内存
- 分代收集：年轻代用复制算法（活下来的少），老年代用另外两种

8. 常见的垃圾回收器？

- 年轻代
    - Serial: 单线程完成垃圾收集，gc期间会暂停其他所有工作线程，适合client端使用
    - ParNew：Serial的多线程版本
    - Parallel Scavenge：提供很多参数来优化吞吐量
- 老年代
    - **CMS**：Concurrent Mark Sweep，为获取最短停顿时间的并发收集器。对于要求服务器响应速度的应用上，这种垃圾回收器非常适合。在启动 JVM 的参数加上“-XX:+UseConcMarkSweepGC”来指定使用 CMS 垃圾回收器。
        CMS 使用的是标记-清除的算法实现的，所以在 gc 的时候回产生大量的内存碎片，当剩余内存不能满足程序运行要求时，系统将会出现 Concurrent Mode Failure，临时 CMS 会采用 Serial Old 回收器进行垃圾清除，此时的性能将会被降低。                                             
        - 初始标记：暂停其他线程
        - 并发标记：gc和用户线程同时运行
        - 重新标记：修正并发标记期间用户程序改动了的部分对象标记
        - 并发清除：gc和用户线程同时运行，进行清扫
    - Serial Old
    - Parallel Old
- G1：面向server的收集器，针对多核大内存的机器，同时满足高吞吐量和低停顿时间。

9. 分代垃圾回收器的工作原理简述一下？

分代回收器有两个分区：老生代和新生代，新生代默认的空间占比总空间的 1/3，老生代的默认占比是 2/3。

新生代使用的是复制算法，新生代里有 3 个分区：Eden、To Survivor、From Survivor，它们的默认占比是 8:1:1，它的执行流程如下：

把 Eden + From Survivor 存活的对象放入 To Survivor 区；
- 清空 Eden 和 From Survivor 分区；
- From Survivor 和 To Survivor 分区交换，From Survivor 变 To Survivor，To Survivor 变 From Survivor。
- 每次在 From Survivor 到 To Survivor 移动时都存活的对象，年龄就 +1，当年龄到达 15（默认配置是 15）时，升级为老生代。大对象也会直接进入老生代。

老生代当空间占用到达某个值之后就会触发全局垃圾收回，一般使用标记整理的执行算法。以上这些循环往复就构成了整个分代垃圾回收的整体执行流程。

10. jvm调优工具？

JDK 自带了很多监控工具，都位于 JDK 的 bin 目录下，其中最常用的是 jconsole 和 jvisualvm 这两款视图监控工具。

- jconsole：用于对 JVM 中的内存、线程和类等进行监控；
- jvisualvm：JDK 自带的全能分析工具，可以分析：内存快照、线程快照、程序死锁、监控内存的变化、gc 变化等。

11. 常用的jvm调优参数？

- -Xms2g：初始化推大小为 2g；
- -Xmx2g：堆最大内存为 2g；
- -XX:NewRatio=4：设置年轻的和老年代的内存比例为 1:4；
- -XX:SurvivorRatio=8：设置新生代 Eden 和 Survivor 比例为 8:2；
– -XX:+UseParNewGC：指定使用 ParNew + Serial Old 垃圾回收器组合；
- -XX:+UseParallelOldGC：指定使用 ParNew + ParNew Old 垃圾回收器组合；
- -XX:+UseConcMarkSweepGC：指定使用 CMS + Serial Old 垃圾回收器组合；
- -XX:+PrintGC：开启打印 gc 信息；
- -XX:+PrintGCDetails：打印 gc 详细信息。
